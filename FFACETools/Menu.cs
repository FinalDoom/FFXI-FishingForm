using System;

namespace FFACETools
{
    public partial class FFACE
    {
        /// <summary>
        /// Wrapper class for menu information from FFACE
        /// </summary>
        public class MenuTools
        {
            #region Constructor

            /// <summary>
            /// Constructor
            /// </summary>
            /// <param name="instanceID">Instance ID generated by FFACE</param>
            public MenuTools (FFACE fface)
            {
                _FFACE = fface;
                _InstanceID = fface._InstanceID;
            } // @ public MenuTools(int instanceID)

            #endregion

            #region Members

            /// <summary>
            /// Our link to FFACE
            /// </summary>
            private FFACE _FFACE { get; set; }

            /// <summary>
            /// Instance ID Generated by FFACE
            /// </summary>
            private int _InstanceID { get; set; }

            /// <summary>
            /// Returns the ID for the current Dialogue or 0 if not dialogue is open
            /// </summary>
            public short DialogID
            {
                get { return GetDialogID(_InstanceID); }
            }

            /// <summary>
            /// Returns the number of dialog options
            /// </summary>
            public int DialogOptionCount
            {
                get
                {
                    if (DialogID == 0)
                        return -1;
                    else
                        return GetDialogIndexCount(_InstanceID);
                }

            }

            ///<summary>
            /// Returns the selected option index
            ///</summary>
            public short DialogOptionIndex
            {
                get
                {
                    if (DialogID == 0)
                        return -1;
                    else
                        return GetDialogIndex(_InstanceID);
                }
            }

            ///<summary>
            /// Returns a class containing the dialog text
            ///</summary>
            public DialogText DialogText
            {
                get
                {
                    if (DialogID == 0)
                        return new DialogText(String.Empty);
                    int size = 4096;
                    byte[] buffer = new byte[size];
                    GetDialogStrings(_InstanceID, buffer, ref size);
                    if (size <= 3)
                        return new DialogText(String.Empty);
                    return new DialogText(System.Text.Encoding.GetEncoding(1252).GetString(buffer, 0, size - 3).Trim());
                }
            }

            /// <summary>
            /// Whether a menu is open or not
            /// </summary>
            public bool IsOpen
            {
                get { return MenuIsOpen(_InstanceID); }

            } // @ public bool IsOpen

            /// <summary>
            /// Name of the menu
            /// </summary>
            public string Name
            {
                get
                {
                    int size = 9;
                    byte[] buffer = new byte[size];
                    MenuName(_InstanceID, buffer, ref size);

                    return System.Text.Encoding.GetEncoding(1252).GetString(buffer, 0, size - 1).Trim();
                }
            } // @ public bool Name

            /// <summary>
            /// Selection string of the menu
            /// </summary>
            public string Selection
            {
                get
                {
                    int size = 12;
                    byte[] buffer = new byte[size];
                    MenuSelection(_InstanceID, buffer, ref size);

                    return System.Text.Encoding.GetEncoding(1252).GetString(buffer, 0, size - 1);
                }
            } // @ public string Selection

            /// <summary>
            /// Help message of the menu
            /// </summary>
            public string Help
            {
                get
                {
                    int size = 100;
                    byte[] buffer = new byte[size];
                    MenuHelp(_InstanceID, buffer, ref size);

                    return System.Text.Encoding.GetEncoding(1252).GetString(buffer, 0, size - 1);
                }
            } // @ public string Help

            /// <summary>
            /// Maximum quantity of the selection
            /// </summary>
            public byte ShopQuantityMax
            {
                get { return FFACE.ShopQuantityMax(_InstanceID); }

            } // @ public byte ShopQuantityMax

            /// <summary>
            /// Current quantity of the selection
            /// </summary>
            public byte ShopQuantity
            {
                get { return FFACE.ShopQuantity(_InstanceID); }

            } // @ public byte ShopQuantity

            private readonly Object TradeMenuLock = new object();
            private ThreadStatus _TradeMenuThread;

            public ThreadStatus lastTradeMenuStatus
            {
                get
                {
                    lock (TradeMenuLock)
                    {
                        return _TradeMenuThread;
                    }
                }
            }

            #endregion

            /// <summary>
            /// Status of OpenTradeMenu
            /// </summary>
            public enum ThreadStatus : byte
            {
                /// <summary>
                /// Default for when the constructor starts, but method was never run.
                /// </summary>
                NotStarted,
                /// <summary>
                /// Method just started the most recent run.
                /// </summary>
                Running,
                /// <summary>
                /// Method failed on last run.
                /// </summary>
                Failed,
                /// <summary>
                /// Method succeeded on last run.
                /// </summary>
                Succeeded
            }

            #region Methods

            /// <summary>
            /// Starts a separate thread that sends key commands in an attempt to Trade with an NPC ONLY. Keeps attempting for 30 seconds.  Does not work well with PC Trade menu!!
            /// </summary>
            /// <param name="TargetID">Target ID of the NPC ONLY to trade with.</param>
            public void OpenTradeMenu (int TargetID)
            {
                // If we're already running, we'll cancel running ANOTHER THREAD!
                if (lastTradeMenuStatus != ThreadStatus.Running)
                {
                    if (( TargetID <= 0 ) || ( TargetID >= 1024 ))
                    {
                        lock (TradeMenuLock)
                        {
                            this._TradeMenuThread = ThreadStatus.Failed;
                            return;
                        }
                    }
                    lock (TradeMenuLock)
                    {
                        this._TradeMenuThread = ThreadStatus.Running;
                    }
                    // Worst case scenario, we check Status and it's reported as "Running"
                    // but was on the last line before Failed/Succeeded.
                    // We still don't want to run another before user gets a chance to verify status.
                    System.Threading.Thread openMenuThread = new System.Threading.Thread(() => OpenTradeMenuThread(TargetID));
                    openMenuThread.Start();
                }
            }

            /// <summary>
            /// Internal function that handled opening the Trade Menu depending on current state.
            /// </summary>
            /// <param name="TargetID">ID of NPC to trade with.</param>
            private void OpenTradeMenuThread (int TargetID)
            {
                lock (TradeMenuLock)
                {
                    this._TradeMenuThread = ThreadStatus.Running;
                }

                String TradeMenuSelection = "Trade";
                String TradeMenuHelp = "";
                String TradeMenuHelpHighlighted = "Trade items or money with current target.";

                bool TradeMenuOpen = false;
                bool TargetCorrect = false;
                bool TradeMenuSelected = false;
                double DistanceToTarget = 0.0f;
                double GoodDistance = 4.0f;

                if (( _FFACE != null ) && ( TargetID > 0 ))
                {
                    DateTime SequenceStart = DateTime.Now;

                    // Continue looping until both Target is correct and TradeMenu is open, or 30seconds pass... this allows for 15s of running to target as well.
                    // (!TargetCorrect || !TradeMenuOpen) && 
                    while (( DateTime.Now - SequenceStart ).TotalMilliseconds < 30000)
                    {
                        TargetCorrect = ( _FFACE.Target.ID == TargetID );
                        TradeMenuOpen = ( _FFACE.Menu.IsOpen && ( _FFACE.Menu.Selection == TradeMenuSelection ) && ( _FFACE.Menu.Help == TradeMenuHelp ) );
                        TradeMenuSelected = ( _FFACE.Menu.IsOpen && ( _FFACE.Menu.Selection == TradeMenuSelection ) && ( _FFACE.Menu.Help == TradeMenuHelpHighlighted ) );
                        DistanceToTarget = _FFACE.Navigator.DistanceTo(TargetID);
                        _FFACE.Navigator.FaceHeading(TargetID);

                        if (!_FFACE.Menu.IsOpen && ( DistanceToTarget > GoodDistance ) && ( DistanceToTarget < 40.0f ))
                        {
                            double store = _FFACE.Navigator.DistanceTolerance;
                            _FFACE.Navigator.DistanceTolerance = GoodDistance;
                            _FFACE.Navigator.GotoNPC(TargetID, 20000);
                            // Restore old DistanceTolerance
                            _FFACE.Navigator.DistanceTolerance = store;
                        }
                        else if (!_FFACE.Menu.IsOpen && !TargetCorrect && ( DistanceToTarget <= GoodDistance ))
                        {
                            _FFACE.Windower.SendKeyPress(KeyCode.TabKey);
                        }
                        else if (!_FFACE.Menu.IsOpen && TargetCorrect && ( DistanceToTarget <= GoodDistance ))
                        {
                            _FFACE.Windower.SendKeyPress(KeyCode.NP_MinusKey);
                        }
                        else if (_FFACE.Menu.IsOpen && TargetCorrect && ( DistanceToTarget <= GoodDistance ) && ( _FFACE.Menu.Selection != TradeMenuSelection ))
                        {
                            _FFACE.Windower.SendKeyPress(KeyCode.UpArrow);
                        }
                        else if (_FFACE.Menu.IsOpen && TargetCorrect && ( DistanceToTarget <= GoodDistance ) && TradeMenuSelected)
                        {
                            _FFACE.Windower.SendKeyPress(KeyCode.EnterKey);
                        }
                        else if (_FFACE.Menu.IsOpen && TargetCorrect && ( DistanceToTarget <= GoodDistance ) && TradeMenuOpen)
                        {
                            // Correct setting
                            lock (TradeMenuLock)
                            {
                                this._TradeMenuThread = ThreadStatus.Succeeded;
                            }
                            return;
                        }
                        // get out of trade menu with wrong person...  Esc -> Enter
                        else if (_FFACE.Menu.IsOpen && !TargetCorrect)
                        {
                            _FFACE.Windower.SendKeyPress(KeyCode.EscapeKey);
                            System.Threading.Thread.Sleep(250);
                            if (TradeMenuOpen)
                            {
                                _FFACE.Windower.SendKeyPress(KeyCode.EnterKey);
                                System.Threading.Thread.Sleep(250);
                            }
                        }
                        System.Threading.Thread.Sleep(125);
                    }
                }
                lock (TradeMenuLock)
                {
                    this._TradeMenuThread = ThreadStatus.Failed;
                }
            }

            public bool SetTradeGil (uint Gil)
            {
                return FFACE.SetNPCTradeInfo(_InstanceID, 0, 0, 0, 0, 0, Gil);
            }

            ///Set Items in npc trade window
            ///<param name="sTinfo">NPCTRADEINFO structure</param>
            ///</summary>
            public bool SetNPCTradeInformation (NPCTRADEINFO sTinfo)
            {
                bool result = false;

                if (sTinfo.items == null)
                {
                    result = FFACE.SetNPCTradeInfo(_InstanceID, 0, 0, 0, 0, 0, sTinfo.Gil);

                }
                else
                {
                    for (int i = 0; i < sTinfo.items.Length; i++)
                    {
                        result = FFACE.SetNPCTradeInfo(_InstanceID, 0, sTinfo.items[i].ItemID, sTinfo.items[i].Index, sTinfo.items[i].Count, (byte)i, sTinfo.Gil);
                        if (!result)
                            break;
                    }
                }
                return result;
            } // @ public bool SetNPCTradeInformation

            /// <summary>
            /// Set items in craft window
            /// </summary>
            /// <param name="sTinfo">NPCTRADEINFO structure</param>
            public bool SetCraftItems (NPCTRADEINFO sTinfo)
            {
                bool result = false;

                if (sTinfo.items == null)
                {
                    return false;
                }
                else
                {
                    for (byte i = 0; i < sTinfo.items.Length; i++)
                    {
                        result = FFACE.SetCraftItem(_InstanceID, 0, sTinfo.items[i].ItemID, sTinfo.items[i].Index, sTinfo.items[i].Count, i);
                        if (!result)
                            break;
                    }
                }
                return result;
            } // @ public bool SetCraftItems

            ///<summary>
            /// Returns a class containing the dialog text
            ///</summary>
            public DialogText GetDialogText ()
            {
                return DialogText;
            }

            ///<summary>
            /// Returns a class containing the dialog text
            ///</summary>
            public DialogText GetDialogText (LineSettings lineSettings)
            {
                if (DialogID == 0)
                    return new DialogText(String.Empty);
                int size = 4096;
                byte[] buffer = new byte[size];
                GetDialogStrings(_InstanceID, buffer, ref size);
                if (size <= 3)
                    return new DialogText(String.Empty);
                return new DialogText(System.Text.Encoding.GetEncoding(1252).GetString(buffer, 0, size - 3).Trim(), lineSettings);
            }

            /// <summary>
            /// Get the menu index or set it by calling the property with a int value
            /// </summary>
            /// <param name="_InstanceID"></param>
            /// <returns></returns>
            public int MenuIndex
            {
                get { return GetMenuIndex(_InstanceID); }
                set { SetMenuIndex(_InstanceID, value); }
                
            } // @ public int GetMenuIndex

            #endregion

        } // @ public class Menu
    } // @ public partial class FFACE
}
